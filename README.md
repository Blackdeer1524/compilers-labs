# Лабораторная работа № 2.4 «Рекурсивный спуск»

## 1 Цель работы

Целью данной работы является изучение алгоритмов построения парсеров методом рекурсивного спуска.

## 2 Исходные данные

В данной лабораторной работе требуется разработать синтаксический анализатор, который, принимая на входе текст на входном языке, строит для него абстрактное синтаксическое дерево.

Описание входного языка и пример программы на нём приводятся в индивидуальном варианте, по описанию следует построить лексическую структуру и грамматику данного языка.

Грамматика входного языка должна быть описана в РБНФ с учётом приоритета и ассоциативности операций. Синтаксический анализатор должен быть написан при помощи методики рекурсивного спуска.

### 2.1 Индивидуальный вариант

Функциональный язык программирования с алгебраическими типами данных

```
<< Объявления типов >>
type List: Cons Int List | Nil.
type Pair: Pair Int Int.
type PairList: PCons Pair PairList | PNil.
type ListList: XCons List ListList | XNil.

<< Объединение двух списков >>
fun (zip List List) -> PairList:

(zip [Cons x xs] [Cons x xs]) -> [PCons [Pair x y] (zip xs ys)] |
(zip xs ys) -> [PNil].

<< Декартово произведение >>
fun (cart_prod List List) -> PairList:

(cart_prod [Cons x xs] ys) -> (append (bind x ys) (cart_prod xs ys)) |
(cart_prod [Nil]) -> PNil.

fun (bind Int List) -> PairList:

(bind x [Cons y ys]) -> [PCons [Pair x y] (bind x ys)] |
(bind x [Nil]) -> [PNil].

<< Конкатенация списков пар >>

fun (append PairList PairList) -> PairList:

(append [PCons x xs] ys) -> [PCons x (append xs ys)] |
(append [PNil] ys) -> ys.

<< Расплющивание вложенного списка >>
fun (flat ListList) -> List:

(flat [XCons [Cons x xs] xss]) -> [Cons x (flat [XCons xs xss])] |
(flat [XCons [Nil] xss]) -> (flat xss) |
(flat [XNil]) -> [Nil].

<< Сумма элементов списка >>
fun (sum List) -> Int:

(sum [Cons x xs]) -> (add x (sum xs)) |
(sum [Nil]) -> 0.

<< Вычисление полинома по схеме Горнера >>
fun (polynom Int List) -> Int:

(polynom x [Nil]) -> 0 |
(polynom x [Cons coef coefs]) -> (add (mul (polynom x coefs) x) coef).

<< Вычисление полинома x³+x²+x+1 >>
fun (polynom1111 Int) -> Int:

(polynom1111 x) -> (polynom x [Cons 1 [Cons 1 [Cons 1 [Cons 1 [Nil]]]]]).
```

Опеделения языка программирования начинаются с ключевого слова (type и fun, соответственно), за которыми идёт заголовок (имя типа и сигнатура функции), двоеточие и набор вариантов (альтернатив для типов и предложений для функций), разделённых знаком вертиальной черты. Определения завершаются точкой.

Вызовы функций записываются в круглых скобках (после открывающей скобки записывается имя функции), конструкторы данных — в квадратных скобках (после открывающей, соответственно, имя конструктора).

Сигнатура функции записывается как вызов функции (т.е. при помощи круглых скобок), в котором вместо аргументов записываются их типы, и тип возвращаемого значения, между которыми записывается знак ->.

Предложение записывается как образец и выражение, разделённые знаком ->. Образец записывается как вызов функции (т.е. при помощи круглых скобок), на месте аргументов находятся их образцы.

Ключевые слова и идентификаторы не чувствительны к регистру.

## 3 Задание

Выполнение лабораторной работы состоит из следующих этапов:

- Составление абстрактного синтаксиса языка.
- Составление лексической структуры и конкретного синтаксиса языка в LL(1) РБНФ.
- Описание абстрактного синтаксического дерева при помощи типов данных выбранного студентом языка реализации.
  - Для Python предпочтительно использовать классы данных (dataclasses).
  - Для Java — классы-записи (record).
  - Для Scala — case-классы.
- Написание лексического анализатора (можно использовать любой из ранее рассмотренных способов).
- Написание синтаксического анализатора методом рекурсивного спуска.

Отметим, что парсер входного языка должен выдавать сообщения об обнаруженных ошибках, включающие координаты ошибки. Восстановление при ошибках реализовывать не нужно.

В качестве языков реализации разрешается использовать любой язык с поддержкой рекурсии.

### 3.1 Ачивки

- Написание чистого синтаксического анализатора на функциональном ЯП — +1 балл. (Про чистый рекурсивный спуск на Рефале-5 можно прочитать здесь). Примечание: на Haskell’е следует писать без использования монад.
- Парсер, восстанавливающийся при ошибках — +2 балла.
