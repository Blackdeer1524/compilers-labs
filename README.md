# Лабораторная работа № 1.2. «Лексический анализатор на основе регулярных выражений»

## 1 Цель работы

Целью данной работы является приобретение навыка разработки простейших лексических анализаторов, работающих на основе поиска в тексте по образцу, заданному регулярным выражением.

## 2 Исходные данные

Стандартная библиотека любого современного языка программирования содержит средства для поиска в тексте образцов, заданных регулярными выражениями. При этом используется расширенный синтаксис записи регулярных выражений, позволяющий по сути выйти за рамки регулярных языков. Механизм поиска по таким регулярным выражениям годится для написания простейших лексических анализаторов. Однако, для этого механизма характерна нелинейная зависимость времени работы от длины распознаваемой лексемы, поэтому в промышленных компиляторах он не используется.

Лабораторную работу можно выполнять на любом языке программирования, стандартная библиотека которого поддерживает регулярные выражения, в качестве примера рассмотрим Java. Стандартная библиотека Java содержит пакет java.util.regex, в котором располагаются классы Pattern и Matcher, предназначенные для поиска по регулярным выражениям. Документация по этому пакету находится по адресу:

http://docs.oracle.com/javase/7/docs/api/java/util/regex/package-summary.html.

Вводную статью по синтаксису регулярных выражений можно прочитать здесь:

http://www.quizful.net/post/Java-RegExp.

Сканер, реализуемый в лабораторной работе, должен выполнять лексический анализ, буквально решая задачу лексического анализа (compiler_slides_lect3.pdf, слайд 13). Анализатор должен итеративно обнаруживать лексический домен, которому соответствует префикс наибольшей длины (при равных длинах выбирается домен с наивысшим приоритетом), формировать из этого префикса токен и отсекать его от текста.

Листинг ниже демонстрирует использование библиотеки регулярных выражений и обнаружение лексического домена в начале строки с использованием регулярных выражений Java.

```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;

// Компиляция для Windows:
// javac -encoding utf8 IdentVsNumber.java

public class IdentVsNumber
{
    public static void main(String args[])
    {
        test_match("Альфа123!");
        test_match("42 + 1");
        test_match("  Ой!  ");
    }

    public record Domain(String name, Pattern pattern) {};

    // Лексические домены
    static Domain[] DOMAINS = {
        new Domain("IDENT", Pattern.compile("\\A\\p{L}[\\p{L}0-9]*")),
        new Domain("NUMBER", Pattern.compile("\\A[0-9]+")),
    };

    public static void test_match(String text)
    {
        for (Domain d : DOMAINS) {
            Matcher m = d.pattern.matcher(text);
            if (m.find()) {
                System.out.println(d.name + ": " + m.group(0));
            } else {
                System.out.println("Домен " + d.name + " не найден");
            }
        }
    }
}
```

В регулярном выражении используется \A для указания, что сопоставление выполняется относительно начала строки.

## 3 Задание

В лабораторной работе необходимо реализовать на языке Java две первые фазы стадии анализа: чтение входного потока и лексический анализ. Чтение входного потока должно осуществляться из файла (в UTF-8), при этом лексический анализатор должен вычислять текущие координаты в обрабатываемом тексте. В результате работы программы в стандартный поток вывода должны выдаваться описания распознанных лексем в формате

```
Тег (координаты): значение
```

Например,

```
IDENT (1, 2): count
ASSIGN (1, 8): :=
NUMBER (1, 11): 100
```

Лексемы во входном файле могут разделяться пробельными символами (пробел, горизонтальная табуляция, маркеры окончания строки), а могут быть записаны слитно (если это не приводит к противоречиям).

Идентификаторы и числовые литералы не могут содержать внутри себя пробельных символов, если в задании явно не указано иного. Комментарии, строковые и символьные литералы могут содержать внутри себя пробельные символы.

Входной файл может содержать ошибки, при обнаружении которых лексический анализатор должен выдавать сообщение с указанием координаты:

```
syntax error (10,2)
```

После обнаружения ошибки лексический анализатор должен восстанавливаться по следующей схеме: из входного потока пропускаются все подряд идущие символы до нахождения следующей лексемы.

Лексический анализатор должен иметь программный интерфейс для взаимодействия с парсером. Рекомендуется реализовывать его как итератор с методом nextToken() для императивных языков или функцию, возвращающую список токенов, для функциональных языков.

В регулярных выражениях рекомендуется использовать классы символов Unicode для обозначения букв, чисел и других подобных множеств. Многие движки регулярных выражений для задания классов используют синтаксис \p{класс}.

⚠Использовать единое регулярное выражение с группами захвата для каждого домена нельзя (в прошлом году можно было, теперь нельзя)! Нужно проверять сопоставление с каждым доменом отдельно.

⚠При защите лабораторной работы преподаватель может потребовать добавить в лексический анализатор домен строк из воспитательных соображений.

## 4 Индивидуальный вариант

- Комментарии: целиком строка текста, начинающаяся с «\*».
- Идентификаторы: либо последовательности латинских букв нечётной длины, либо последовательности символов «\*».
- Ключевые слова: «with», «end», «\*\*».
